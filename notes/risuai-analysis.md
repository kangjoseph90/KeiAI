# RisuAI 코드베이스 분석 프롬프트

아래 프롬프트를 다른 AI 에이전트(Gemini CLI 등)에 RisuAI 레포와 함께 넘겨주세요.

---

## PROMPT START

당신은 소프트웨어 아키텍트입니다. `RisuAI` 레포지토리의 코드를 분석하여 **기능 인벤토리(Feature Inventory)**와 **아키텍처 분석 보고서**를 작성해야 합니다.

이 분석은 RisuAI와 동일한 문제 도메인(AI 캐릭터 채팅 앱)의 신규 프로젝트를 설계하기 위한 참고 자료로 사용됩니다. 따라서 "이 기능이 존재한다"뿐만 아니라 "이 기능이 내부적으로 어떻게 작동하는가"를 데이터 흐름 수준까지 파악해야 합니다.

### 분석 대상 경로

- 핵심 비즈니스 로직: `src/ts/`
- UI 컴포넌트: `src/lib/`
- 프로젝트 문서: `AGENTS.md`, `plugins.md`
- 설정/빌드: `package.json`, `vite.config.ts`

### Part 1: 기능 인벤토리 (Feature Inventory)

아래 카테고리별로 RisuAI가 제공하는 **모든 기능**을 빠짐없이 나열하세요. 각 기능에 대해 다음 정보를 포함하세요:

- **기능명**
- **설명** (1-2줄)
- **핵심 소스 파일** (파일 경로)
- **복잡도** (Low / Medium / High / Very High)
- **의존성** (이 기능이 의존하는 다른 기능들)

**카테고리:**

1. **데이터 저장 & 영속성 (Storage)**
    - DB 구조, 세이브 포맷, 플랫폼별 어댑터, 에셋 관리, 내보내기/가져오기, 암호화
    - 특히 "싱글톤 DB" 구조의 실체를 파악하세요: 전체 데이터가 하나의 객체로 직렬화되는지, 어떤 단위로 저장되는지, 세이브 시 전체를 덤프하는지 변경분만 저장하는지

2. **AI 처리 파이프라인 (Processing)**
    - 채팅 처리 흐름, 프롬프트 조립, API 요청, 응답 파싱, 스트리밍
    - `process/index.svelte.ts`에서 시작하는 전체 요청-응답 사이클을 추적하세요

3. **프롬프트 엔진 (Prompt Engine)**
    - 시스템 프롬프트 조립, 메모리 시스템(HypaMemory V2/V3, SupaMemory 등), 로어북, 페르소나, 프리셋/템플릿
    - 최종 API 요청에 포함되는 메시지 배열이 어떤 순서와 로직으로 조립되는지 상세히 분석하세요

4. **캐릭터 카드 시스템 (Character Cards)**
    - 캐릭터 데이터 구조(TypeScript 인터페이스), 가져오기/내보내기 포맷(.risum, .risup, .charx, Tavern PNG), 캐릭터 편집 기능
    - `characterCards.ts`의 데이터 스키마를 추출하세요

5. **UI/UX 시스템**
    - 라우팅 방식, 테마 시스템, 반응형(모바일/데스크톱), Visual Novel 모드, GUI 모드(Classic, WaifuLike 등)

6. **플러그인 시스템 (Plugins)**
    - 플러그인 API, iframe 샌드박싱, 커스텀 AI 프로바이더, 이벤트 훅
    - `plugins.md` 문서를 참고하세요

7. **외부 연동 (Integrations)**
    - 지원되는 모든 AI 프로바이더, TTS, 이미지 생성(Stable Diffusion), 번역, MCP, Horde

8. **동기화 & 클라우드 (Sync)**
    - Google Drive 백업, 멀티유저 동기화, Realm(마켓플레이스)
    - 데이터 동기화 시 전체 세이브 파일을 올리는지, 변경분만 올리는지 파악하세요

9. **파서 & 스크립팅 (Parser)**
    - 메시지 파싱, 매크로/변수 시스템, 커스텀 스크립팅, 조건부 로직, 트리거
    - `parser.svelte.ts`와 `process/scriptings.ts`의 관계를 분석하세요

10. **기타**
    - 토크나이저, 핫키, 알림, 업데이트 시스템, i18n, PNG 청크 처리 등

### Part 2: 아키텍처 심층 분석

#### 2-1. 데이터 아키텍처 (가장 중요)

RisuAI의 데이터 저장 방식이 갖는 **구조적 한계와 장점**을 분석하세요.

- `src/ts/storage/` 내 모든 파일을 읽고, 데이터가 어떤 형태로 저장되는지 파악하세요.
- 아래 질문에 답하세요:
    - 데이터는 어떤 단위로 저장되는가? (개별 레코드 vs 전체 덤프)
    - 캐릭터 1개의 메시지를 1개 추가할 때 실제로 어떤 I/O가 발생하는가?
    - 채팅 기록이 많아질수록 성능에 어떤 영향이 있는가?
    - 멀티 디바이스 동기화 시 어떤 데이터 단위로 전송되는가?

#### 2-2. 채팅 처리 파이프라인

유저가 메시지를 보내는 순간부터 AI 응답이 화면에 렌더링되기까지의 **전체 데이터 흐름**을 단계별로 기술하세요.

```
[유저 입력] → [???] → [???] → ... → [화면 렌더링]
```

각 단계에서:

- 어떤 함수가 호출되는지 (파일명 + 함수명)
- 데이터가 어떻게 변환되는지
- 어떤 부가 처리(메모리, 로어북, 스크립팅 등)가 끼어드는지

#### 2-3. 프롬프트 엔진 아키텍처

최종적으로 AI API에 전송되는 메시지 배열(messages[])이 어떻게 조립되는지 분석하세요.

- 시스템 프롬프트, 캐릭터 설명, 로어북, 메모리 요약, 최근 대화 기록, 유저 페르소나 등이 어떤 순서로 삽입되는지
- 메모리 시스템(HypaMemory 등)이 토큰 제한을 어떻게 관리하는지
- 프리셋/템플릿이 이 조립 과정에 어떻게 개입하는지

#### 2-4. 에셋 관리

- 에셋(이미지 등)이 어떻게 저장, 참조, 동기화되는지
- "인레이(Inlay) 에셋"과 일반 에셋의 차이
- Realm(마켓플레이스)에서 캐릭터를 공유할 때 에셋은 어떻게 처리되는지

### Part 3: 의존성 관계 맵

위에서 나열한 주요 기능들 사이의 의존성을 **방향 그래프 형태의 텍스트 다이어그램**으로 그려주세요.

```
[Storage] ← [Character Cards] ← [Chat Processing]
                                       ↓
                                [Prompt Engine] → [API Request]
                                       ↑
                                [Memory System]
                                [Lorebook]
```

### 출력 형식

- 마크다운(`.md`) 파일 형식으로 출력하세요.
- 모든 파일 경로는 레포 루트(`src/ts/...`) 기준 상대 경로로 표기하세요.
- 코드 조각을 인용할 때는 반드시 파일명과 라인 범위를 명시하세요.
- 추측이 아닌 코드에서 확인한 사실만 기술하세요. 확인이 불가능한 부분은 `[미확인]`으로 표기하세요.

### 주의사항

- RisuAI의 코드를 복사하거나 재사용하려는 것이 아닙니다. 기능 구조와 설계 패턴을 참고하기 위한 분석입니다.
- 특히 **데이터 저장 방식의 한계점**과 **프롬프트 엔진의 조립 로직**을 가장 상세하게 분석해주세요. 이 두 가지가 가장 중요합니다.
- 파일 크기가 큰 파일들(`cbs.ts` 104KB, `characterCards.ts` 75KB, `globalApi.svelte.ts` 68KB, `parser.svelte.ts` 65KB 등)은 개략적 구조만 파악하고 모든 줄을 읽으려 하지 마세요.

## PROMPT END
