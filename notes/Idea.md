🏛️ E2EE + BYOK AI 채팅 앱 핵심 아키텍처 설계도 (Local-First 기반)

1. 로컬-퍼스트 (Local-First) 및 게스트 모드 아키텍처

- 오프라인 우선 진행: 앱을 켜면 서버 연결 여부와 상관없이 먼저 'Guest ID'와 메모리용 '마스터 키(M)'를 로컬에서 즉시 발급 (IndexedDB 저장). 유저는 로그인 없이 즉각 앱 사용 가능.
- 서버 연동 (Link Account): 이후 유저가 가입(로그인)을 결심하면, 아래의 인증 흐름을 통해 그동안 게스트로 썼던 폰의 마스터 키 M을 서버용 패키지로 포장하여 서버에 업로드 연동함.
- 데이터 레이어 분리:
    1. Local DB (Storage Layer): Dexie(웹), Tauri DB 등 Adapter 패턴 적용. 무조건 AES-GCM으로 암호화된 Byte Array 형태로만 저장 및 조회.
    2. Svelte Store (In-Memory Layer): 평문 변환 및 처리를 담당. 3계층(Global, Active Character, Active Chat)으로 나뉘며 방을 벗어나면 평문은 Garbage Collect 됨.
    3. UI / Prompt Engine: 스토어에 복호화되어 있는 JSON 데이터를 자유롭게 조작(정규식, 삽입 등). 로컬 DB 조작은 의식하지 않음.

2. 키 생성 및 인증 (Authentication & Key Derivation)

- 기본 원칙: 유저의 비밀번호 하나로 서버 로그인(인증)과 클라이언트 암호화(복호화)를 완벽하게 분리.
- 회원가입 흐름 (Link Account):
    1. 클라이언트에서 무작위 솔트(Salt) 16바이트 생성.
    2. 비밀번호 + 솔트를 KDF(PBKDF2 등, 60만 번 반복)에 돌려 512비트 생성.
    3. 절반으로 쪼개어 **X (로그인용 신분증)**와 Y (금고 열쇠) 획득.
    4. 기존에 오프라인/게스트로 쓰던 마스터 키 M (AES-GCM)을 Y로 암호화하여 M(Y) 생성.
    5. 서버 DB 저장: 아이디, 솔트, X, M(Y) (서버는 비밀번호, Y, M을 절대 모름).

3. 세션 유지 및 클라이언트 보안 (Session & Client Security)

- API 로그인 상태 유지:
    - 매 요청마다 X를 보내지 않음.
    - [1차 통신] 이메일을 보내 salt 획득 -> [로컬 연산] X, Y 조립 -> [2차 통신] X를 보내 인증 토큰(JWT 등) 발급. 이후 통신은 이 토큰으로 처리.
    - 만약 다른 기기에서 로그인 시, 서버에서 받은 M(Y)를 Y로 풀어 M을 획득 후 로컬 DB의 기존 게스트 데이터들을 새 M으로 몽땅 재암호화(Merge) 진행.
- 마스터 키(M) 로컬 보관:
    - 메모리에 풀려있는 진짜 열쇠 M은 `extractable: false` 옵션을 걸어 생성/임포트(Web Crypto API).
    - XSS 같은 악성 스크립트가 로컬에서 키의 Raw Byte를 탈취하는 것을 원천 차단.

4. 데이터 저장 메커니즘 (Data at Rest)

- 점진적 동기화 & 지연 로딩 (Progressive Sync / Lazy Load):
    - 무거운 복호화 및 DB 트래픽을 피하기 위해 모든 엔티티(캐릭터, 채팅)는 `Summary(요약)` 필드와 `Data(본문)` 필드로 쪼개어 각각 암호화.
    - 메인 화면에선 가벼운 Summary만 복호화해 렌더링. 특정 방에 진입할 때만 깊은 Data와 수백 개의 Messages를 복호화해 인메모리에 올림.
- 유저의 API 키 (BYOK):
    - 클라이언트가 마스터 키 M으로 암호화하여 DB에 전송. 개발자 서버 탈취 시에도 API 키는 안전함.
- 채팅 메시지 등 기타 데이터:
    - 모든 데이터는 스키마리스 JSON 형태로 묶어, M과 무작위 IV를 사용해 암호화(Ciphertext).
    - 서버 DB와 로컬 DB 모두 오직 암호문과 IV만 저장. 새 기능(프리셋, 로어북 등)을 추가할 때 테이블 스키마 변경 부담이 없음.

5. 백엔드 연동 및 동기화 전략 (PocketBase)

- 서버의 역할 (Blind Data Store):
    - 서버(PocketBase)는 데이터 내용(평문)을 전혀 모르는 단순 바이트 배열 창고 및 로그인 문지기로만 동작.
    - 보안이나 데이터 가공 로직을 서버에 둘 필요가 없어 개발 비용이 극단적으로 낮음.
- 커스텀 로그인 훅 (Authentication Flow):
    - 포켓베이스 내장 `authWithPassword`를 활용하되, 클라이언트에서 미리 "Salt"를 받아 파생키(X, Y)를 계산해야 함.
    - `GET /api/salt/:email`: 비밀번호 인증 없이 이메일로 Salt만 반환하는 커스텀 JS 훅 구축.
    - 받아온 Salt로 클라이언트에서 X를 계산 후, 진짜 비밀번호 대신 X를 전송해 포켓베이스를 속임(안전하게 E2EE 구현).
- 블라인드 동기화 춤 (Blind Sync Dance):
    - 로컬 DB와 포켓베이스 DB의 테이블 스키마는 동일(BaseRecord 형태).
    - [업로드/Push]: 오프라인에 쌓인 `lastSyncTime` 이후의 암호문 바이트 배열들을 서버에 그대로 Upsert.
    - [다운로드/Pull]: 타 기기에서 업로드된 서버의 최신 암호문들을 가져와 로컬 DB 덮어쓰기 (LWW: Last-Write-Wins 기반).
    - `Realtime Subscription` 웹소켓을 활용해 클라이언트 간 즉시 푸시/알림 가능.

6. 하이브리드 AI 프록싱 (API Routing)

- 토글 기능 지원 (유저 선택권 보장):
    - 직접 요청 (Direct): 클라이언트 ➡️ OpenAI/Claude. 개발자 서버를 아예 거치지 않는 궁극의 프라이버시 (CORS 에러 감수).
    - 프록시 요청 (Proxy): 클라이언트 ➡️ 엣지 프록시 ➡️ OpenAI/Claude.
- 프록시 서버 보안 원칙 (Stateless):
    - Vercel Edge Functions, Cloudflare Workers 등 인메모리 환경 사용.
    - DB 연결 없음, 로깅(console.log) 없음. 요청을 포워딩만 하고 메모리 즉시 소멸. 코드 오픈소스로 신뢰 확보.

7. 최악의 시나리오 대비 (계정 복구)

- 비상 복구키(Recovery Code) 발급:
    - 가입 시 16자리 무작위 문자열 발급 (유저가 직접 아날로그 보관).
    - 앞 8자리 (암호화용 Z): M을 잠가서 **M(Z)**로 서버에 보관.
    - 뒤 8자리 (인증 토큰): 단방향 해시로 서버에 저장.
- 비밀번호 분실 시 흐름:
    1. 이메일 인증으로 본인 확인.
    2. 유저가 복구키 전체 입력 ➡️ 인증 토큰(뒤 8자리)을 서버로 보내 API 업데이트 권한 획득.
    3. 클라이언트에서 앞 8자리로 M(Z)를 풀어 M 획득 (AES-GCM 무결성 검증 통과 시 성공).
    4. 새로운 비밀번호 입력 ➡️ 새로운 KDF(새 솔트, X, Y) 생성 ➡️ 기존 M을 새로운 Y로 묶어 서버 덮어쓰기. (과거 데이터 완벽 보존).
